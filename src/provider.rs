use algonaut::{
    algod::v2::Algod,
    core::{Address, MicroAlgos, SuggestedTransactionParams},
    transaction::{
        tx_group::TxGroup, Pay, SignedTransaction, Transaction, TransferAsset, TxnBuilder,
    },
};
use anyhow::{anyhow, Result};
use data_encoding::BASE64;
use log::debug;
use my_algo::MyAlgo;
use serde::{Deserialize, Serialize};

// #[derive(Debug, Clone, Eq, PartialEq)]
pub struct Provider {
    algod: Algod,
    my_algo: MyAlgo,
}

impl Provider {
    pub fn new(algod: Algod, my_algo: MyAlgo) -> Provider {
        Provider { algod, my_algo }
    }

    pub async fn connect_wallet(&self) -> Result<Address> {
        self.my_algo
            .connect_wallet()
            .await
            .and_then(|addresses| match addresses.get(0) {
                Some(address) => Ok(address.to_owned()),
                None => Err(anyhow!(
                    "Unexpected: My Algo connect success but no addresses"
                )),
            })
    }

    /// Generate a swap link containing a serialized tx group with my signed tx and the peer's unsigned tx.
    pub async fn generate_link(&self, swap: Swap) -> Result<SwapLink> {
        Ok(SwapLink(format!(
            "http://localhost:8000/submit/{}",
            self.to_swap_request(swap).await?.as_url_encoded_str()?
        )))
    }

    /// Process peer's swap request: sign my tx and submit the tx group to the network.
    pub async fn decode_swap(&self, encoded_swap: String) -> Result<SwapRequest> {
        SwapRequest::from_url_encoded_str(encoded_swap)
    }

    /// Process peer's swap request: sign my tx and submit the tx group to the network.
    pub async fn submit_swap(&self, request: SwapRequest) -> Result<String> {
        let my_tx = request.unsigned_tx;
        let my_signed_tx_my_algo = self.my_algo.sign(&my_tx).await?;
        let my_signed_tx = rmp_serde::from_slice(&my_signed_tx_my_algo.blob)?;

        let peer_signed_tx = request.signed_tx;

        debug!("Sending transaction group to node");
        debug!("My signed tx: {:?}", my_signed_tx);
        debug!("Peer signed tx: {:?}", peer_signed_tx);

        let send_response = self
            .algod
            // The order here has to match the order when assigning the group id.
            .broadcast_signed_transactions(&[peer_signed_tx, my_signed_tx])
            .await;
        debug!("Response: {:?}", send_response);
        Ok(send_response?.tx_id)
    }

    async fn to_swap_request(&self, swap: Swap) -> Result<SwapRequest> {
        let mut my_tx = self
            .to_tx(swap.me, swap.peer, swap.send, swap.my_fee)
            .await?;
        let mut peer_tx = self
            .to_tx(swap.peer, swap.me, swap.receive, swap.peer_fee)
            .await?;
        TxGroup::assign_group_id(vec![&mut my_tx, &mut peer_tx])?;

        let my_signed_tx_my_algo = self.my_algo.sign(&my_tx).await?;
        let my_signed_tx = rmp_serde::from_slice(&my_signed_tx_my_algo.blob)?;
        Ok(SwapRequest {
            signed_tx: my_signed_tx,
            unsigned_tx: peer_tx,
        })
    }

    async fn to_tx(
        &self,
        sender: Address,
        receiver: Address,
        unit: Transfer,
        fee: MicroAlgos,
    ) -> Result<Transaction> {
        Ok(TxnBuilder::with(
            SuggestedTransactionParams {
                fee,
                ..self.algod.suggested_transaction_params().await?
            },
            match unit {
                Transfer::Algos { amount } => {
                    Pay::new(sender, receiver, MicroAlgos(amount)).build()
                }
                Transfer::Asset { id, amount } => {
                    TransferAsset::new(sender, id, amount, receiver).build()
                }
            },
        )
        .build())
    }
}

#[derive(Debug, Clone)]
pub struct ValidatedSwapInputs {
    pub peer: Address,
    pub send: Transfer,
    pub receive: Transfer,
    pub my_fee: MicroAlgos,
    pub peer_fee: MicroAlgos,
}

impl ValidatedSwapInputs {
    pub fn to_swap(&self, me: Address) -> Swap {
        Swap {
            me,
            peer: self.peer,
            send: self.send.clone(),
            receive: self.receive.clone(),
            my_fee: self.my_fee,
            peer_fee: self.peer_fee,
        }
    }
}

#[derive(Debug, Clone)]
pub struct Swap {
    pub me: Address,
    pub peer: Address,
    pub send: Transfer,
    pub receive: Transfer,
    pub my_fee: MicroAlgos,
    pub peer_fee: MicroAlgos,
}

#[derive(Debug, Clone)]
pub enum Transfer {
    Algos { amount: u64 },
    Asset { id: u64, amount: u64 },
}

/// The transactions to perform the swap, generated by the swap's creator,
/// sent to the peer to finish signing and submit to the network.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapRequest {
    /// Creator's transaction: already signed.
    pub signed_tx: SignedTransaction,
    /// Peer's transaction: to be signed.
    pub unsigned_tx: Transaction,
}

impl SwapRequest {
    fn as_url_encoded_str(&self) -> Result<String> {
        let serialized = BASE64.encode(&rmp_serde::to_vec_named(self)?);
        Ok(urlencoding::encode(&serialized).to_string())
    }

    fn from_url_encoded_str(str: String) -> Result<SwapRequest> {
        Ok(rmp_serde::from_slice(
            &BASE64.decode(urlencoding::decode(&str)?.as_bytes())?,
        )?)
    }
}

/// Wrapper for the link path containg the encoded swap data.
#[derive(Debug, Clone)]
pub struct SwapLink(pub String);
